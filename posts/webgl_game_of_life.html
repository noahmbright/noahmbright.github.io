<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title> The Game of Life using Every Last Bit </title>
    <link rel="stylesheet" href="/style.css">
    <script defer src="/navbar.js"></script>
</head>

<body>
    <header>
        <nav-bar></nav-bar>
    </header>

    <section class="main-content">
        <h2> The Game of Life, in WebGL, using Every Last Bit </h2>

        <p>
            Conway's Game of Life (GoL) is the probably most famous cellular
            automaton there is, amongst people who consider famous
            cellular automata, at least. GoL is simulated on a 2D grid.
            At a given timestep, or generation, a cell on that grid is either
            alive or dead. To update a cell for the next generation, the
            following rules are used:
            <ul>
                <li>
                    If a cell is alive, and has 2 or 3 living neighbors, it
                    remains alive,
                </li>
                <li>
                    If a cell is dead, and has 3 living
                    neighbors, it turns alive,
                </li>
                <li>
                    All other cells are dead.
                </li>
            </ul>

            Here a cell's "neighbors" are its 8 surrounding cells. Living cells
            with fewer than two neighors die by "underpopulation"; those with
            greater than three die by "overpopulation". Dead cells with exactly
            three neighbors come to life by "reproduction".
        </p>

        <p>
            GoL is much more interesting than I am capable of explaining. It is
            Turing complete, so, within the Game of Life itself, you can build
            computers that themselves are capable of simulating GoL, and in
            principle that can spiral on forever. GoL suffers from the halting
            problem, the name itself comes from John Conway's own surprise at
            the complexity that emerged from such simple rules. I won't try to
            sell you on how interesting GoL is; there are plenty of better
            resources for that. I'll just try to show you how to implement it.
        </p>

        <h2> A CPU Implementation </h2>

        <p>
            The most straightforward way to implement GoL would be to use an 
            everyday general-purpose programming language compiled/interpreted
            into CPU instructions - because eventually we'll be running WebGL,
            I'll use JavaScript. To represent the board, we can use a list of 
            lists. We know that each cell contains a single bit of information:
            alive/dead, 1/0. It would be natural to use an array of 1-bit data
            structures to represent that, but CPUs are limited in their minimally
            addressible alignments, and that same problem will rear its head 
            when we put this on the GPU. For now, we'll just use integers and 
            use 1 for alive and 0 for dead, letting the other 63, 31, or however
            many other bits go to waste for now.
        </p>

        <p>
            Another issue to deal with here are boundary conditions - we can't
            index outside of the array boundary, so we need a policy for
            dealing with cells on the edge of the grid whose neighbors would
            extend out of bounds. The two obvious choices would be to treat
            these out of bounds indices as 0, or to apply periodic boundary
            conditions, allowing the out of bounds incides to wrap around to
            the other side of the board. Handling that on the GPU will look
            much different that it would in JS, so I'll leave that as an
            exercise.
        </p>

        <p>
            The final thing to consider is the timing of updates. In GoL time,
            the value of this cell at the next time step depends on this cell's
            neighbors right now, and all cells update simultaneously. However,
            our JS will iterate through each cell sequentially. If it updates 
            cells in place as it goes, cells processed later on will see their
            neighbors' values at the following time step, not the current one.
        </p>

        <p>
            There are two ways to solve this, either using extra time or extra
            space. The former approach involves using only a single copy of the
            board, and instead of updating each cell to 0 or 1, you can use
            additional values like -1 or 2 to indicate something like currently
            dead/alive but alive/dead in the next time step. Then you can make
            a second pass to update the -1s and 2s into 0s and 1s. Not only does
            this require more than one bit of data per cell, but it is also less
            amenable to a GPU implementation - GPUs cannot write to the same array
            that they are currently sampling from. That is the ultimate data race.
        </p>

        <p>
            That leaves us with the latter approach, using extra space. This is
            probably easier both to understand and to implement. Simply write to
            a second array holding the state at the next time step, while sampling
            the array holding the state at the current step. When finished, just 
            swap the pointers to each array.
        </p>

        
    </section>

</body>

</html>
